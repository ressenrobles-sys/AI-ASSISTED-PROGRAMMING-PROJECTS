<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Parametric 3D Truss Modeler</title>
  <style>
    body { margin:0; overflow:hidden; font-family: Arial; }
    #ui {
      position:absolute;
      top:10px;
      left:10px;
      background:white;
      padding:15px;
      border-radius:8px;
      box-shadow:0 0 10px rgba(0,0,0,0.3);
      z-index:10;
    }
    #ui input { width:80px; }
  </style>
</head>
<body>

<div id="ui">
  <h3>Truss Parameters</h3>
  <label>Span: <input id="span" type="number" value="20"></label><br><br>
  <label>Height: <input id="height" type="number" value="5"></label><br><br>
  <label>Bays: <input id="bays" type="number" value="8"></label><br><br>
  <label>Width (3D): <input id="width" type="number" value="4"></label><br><br>
  <button onclick="generateTruss()">Generate</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>

<script>
let scene, camera, renderer, controls;
let trussGroup;

init();
generateTruss();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf0f0f0);

  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(30, 20, 30);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  controls = new THREE.OrbitControls(camera, renderer.domElement);

  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(10,20,10);
  scene.add(light);

  scene.add(new THREE.AmbientLight(0x888888));

  const grid = new THREE.GridHelper(100, 100);
  scene.add(grid);

  animate();
}

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}

function generateTruss() {

  if (trussGroup) scene.remove(trussGroup);
  trussGroup = new THREE.Group();

  const span = parseFloat(document.getElementById("span").value);
  const height = parseFloat(document.getElementById("height").value);
  const bays = parseInt(document.getElementById("bays").value);
  const width = parseFloat(document.getElementById("width").value);

  const dx = span / bays;

  let nodesFront = [];
  let nodesBack = [];

  // Generate nodes
  for (let i=0; i<=bays; i++) {
    let x = i * dx;
    let y = (i % 2 === 0) ? 0 : height;

    nodesFront.push(new THREE.Vector3(x, y, 0));
    nodesBack.push(new THREE.Vector3(x, y, width));
  }

  const material = new THREE.LineBasicMaterial({color:0x0000ff});

  function addMember(p1, p2) {
    const geometry = new THREE.BufferGeometry().setFromPoints([p1, p2]);
    const line = new THREE.Line(geometry, material);
    trussGroup.add(line);
  }

  // Front truss
  for (let i=0; i<bays; i++) {
    addMember(nodesFront[i], nodesFront[i+1]);
  }

  // Back truss
  for (let i=0; i<bays; i++) {
    addMember(nodesBack[i], nodesBack[i+1]);
  }

  // Vertical members
  for (let i=0; i<=bays; i++) {
    addMember(nodesFront[i], nodesBack[i]);
  }

  // Diagonal bracing
  for (let i=0; i<bays; i++) {
    addMember(nodesFront[i], nodesBack[i+1]);
    addMember(nodesBack[i], nodesFront[i+1]);
  }

  scene.add(trussGroup);
}
</script>

</body>
</html>
